{"meta":{"title":"FunriLySpace","subtitle":"天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。","description":"天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。","author":"FunriLy","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2017-02-04T09:49:51.000Z","updated":"2017-02-04T10:13:12.901Z","comments":true,"path":"aboutme/index.html","permalink":"http://yoursite.com/aboutme/index.html","excerpt":"","text":"FunriLy目前就读于广东工业大学计算机学院某系。自己本来就是个半瓢水的逗比。本来语文都没学好，却还要装逼秀英语选择了计算机专业。一阵子折腾下来，只学会了多种编程语言的”Hello Word !”。同时作为一名专业的码农搬砖工，主写JAVA后端，却老是去搞各种奇奇怪怪的东西。生活中，喜欢组织带人去各种浪，浪到天昏地暗，可骨子里却暗藏着2.5次元的宅属性~~~(｡•ˇ‸ˇ•｡) 哼！都怪你们(`ȏ´)也不哄哄人家(〃′o`)人家超想哭的，捶你胸口，大坏蛋！！！ (￣^￣)ゞ咩QAQ 捶你胸口 你好讨厌！(=ﾟωﾟ)ﾉ要抱抱嘤嘤嘤哼，人家拿小锤锤捶你胸口！！！(｡• ︿•̀｡)大坏蛋，打死你(つд⊂)"},{"title":"MY WORKS","date":"2017-02-02T08:33:28.000Z","updated":"2017-02-02T08:33:28.572Z","comments":true,"path":"my_works/index.html","permalink":"http://yoursite.com/my_works/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2017-02-02T08:34:11.000Z","updated":"2017-02-02T08:34:11.760Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java调用cmd编译(一)","slug":"java调用cmd编译C文件(一)","date":"2017-02-05T02:21:51.000Z","updated":"2017-02-05T02:56:49.232Z","comments":true,"path":"2017/02/05/java调用cmd编译C文件(一)/","link":"","permalink":"http://yoursite.com/2017/02/05/java调用cmd编译C文件(一)/","excerpt":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。","text":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 如何使用Java来编译运行C文件(一)前言码农的小日子过得好好的，指导老师一个兴起要求搞一个自己的在线编译网站，我们这种做小弟的只能老老实实地去搞。还好刚刚结束了考试与比赛，因为各种原因导致原定于寒假开工的项目延迟到下学期了，刚好趁这段空闲的时间来搞一搞。其实，自己感觉搞这个的话也挺好玩的~ 介绍利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 前期技术准备1. 调用cmd编译C文件先说明一下，我的操作系统是Win10，Linux环境下会有所不同；而编译环境是GCC。 打开命令行界面并确认GCC可用123键盘win + r （ 这里的r是run的意思）输入cmd,回车，你就看到了命令行输入gcc -v --如果返回了结果，那么继续，如果不识别，那么请立刻参考“附录” 如： 写好C语言源文件创建test.c文件，输入以下代码：123456#include&lt;stdio.h&gt;int main()&#123; printf(\"hello world\\n\"); getchar(); rerturn 0;&#125; 将.c文件放于E盘中，方便操作。 编译该.c文件12E: cdgcc test.c -o test 这里的cd是change directory的意思 接下来，在E盘中就能找到test.exe文件，双击运行即可。备注：也可通过命令行来运行该文件！ 附录当你输入gcc时，之所以你看到了：1不是内部或外部命令，也不是可运行的程序或批处理文件。 因为你没有在自己的环境变量之中添加gcc.exe的路径。于是系统完全不知道去哪里寻找gcc.exe。关于GCC的安装配置我就不废话了，直接借用CSDN上firefoxbug大神的博文，附上链接Windows下安装配置GCC编译器 2. Java运行命令行java的Runtime.getRuntime().exec(string)可以调用执行cmd指令。123456789cmd /c dir 是执行完dir命令后关闭命令窗口。cmd /k dir 是执行完dir命令后不关闭命令窗口。cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。可以用cmd /?查看帮助信息。 附上一个简单的调用demo12345678910111213 public static void main(String[] args) &#123; String string = \"要执行的cmd语句\"; Runtime run = Runtime.getRuntime(); try &#123; Process process = run.exec(\"cmd.exe /k start \" + string); /* 对进程 process 进行操作 */ process.destroy(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 关于多条cmd语句的执行问题在许多情况下，只调用一条cmd语句明显不能满足我们的需求，需要多条cmd语句来共同配合使用。关于网上使用&amp;&amp;来连接多条cmd语句的调用使用，本人亲测不成功，也有可能是我的操作有错(可与网上案例一模一样的代码运行不成功我也没办法啊，也考虑过是Windows操作系统的影响)。最后，我是使用了bat批处理文件来解决这个问题的，具体案例请参考我的开发案例。 常见的CMD命令注意：以下命令均由互联网收集而来！！！1. gpedit.msc—–组策略2. sndrec32——-录音机3. Nslookup——-IP地址侦测器4. explorer——-打开资源管理器5. logoff———注销命令6. tsshutdn——-60秒倒计时关机命令7. lusrmgr.msc—-本机用户和组8. services.msc—本地服务设置9. oobe/msoobe /a—-检查XP是否激活10. notepad——–打开记事本11. cleanmgr——-垃圾整理12. net start messenger—-开始信使服务13. compmgmt.msc—计算机管理14. net stop messenger—–停止信使服务15. conf———–启动netmeeting16. dvdplay——–DVD播放器17. charmap——–启动字符映射表18. diskmgmt.msc—磁盘管理实用程序19. calc———–启动计算器20. dfrg.msc——-磁盘碎片整理程序21. chkdsk.exe—–Chkdsk磁盘检查22. devmgmt.msc— 设备管理器23. regsvr32 /u .dll—-停止dll文件运行24. drwtsn32—— 系统医生25. rononce -p —-15秒关机26. dxdiag———检查DirectX信息27. regedt32——-注册表编辑器28. Msconfig.exe—系统配置实用程序29. rsop.msc——-组策略结果集30. mem.exe——–显示内存使用情况31. regedit.exe—-注册表32. winchat——–XP自带局域网聊天33. progman——–程序管理器34. winmsd———系统信息35. perfmon.msc—-计算机性能监测程序36. winver———检查Windows版本37. sfc /scannow—–扫描错误并复原38. taskmgr—–任务管理器（2000／xp／200339. winver———检查Windows版本40. wmimgmt.msc—-打开windows管理体系结构(WMI)41. wupdmgr——–windows更新程序42. wscript——–windows脚本宿主设置43. write———-写字板44. winmsd———系统信息45. wiaacmgr——-扫描仪和照相机向导46. winchat——–XP自带局域网聊天47. mem.exe——–显示内存使用情况48. Msconfig.exe—系统配置实用程序49. mplayer2——-简易widnows media player50. mspaint——–画图板51. mstsc———-远程桌面连接52. mplayer2——-媒体播放机53. magnify——–放大镜实用程序54. mmc————打开控制台55. mobsync——–同步命令56. dxdiag———检查DirectX信息57. drwtsn32—— 系统医生58. devmgmt.msc— 设备管理器59. dfrg.msc——-磁盘碎片整理程序60. diskmgmt.msc—磁盘管理实用程序61. dcomcnfg——-打开系统组件服务62. ddeshare——-打开DDE共享设置63. dvdplay——–DVD播放器64. net stop messenger—–停止信使服务65. net start messenger—-开始信使服务66. notepad——–打开记事本67. nslookup——-网络管理的工具向导68. ntbackup——-系统备份和还原69. narrator——-屏幕“讲述人”70. ntmsmgr.msc—-移动存储管理器71. ntmsoprq.msc—移动存储管理员操作请求72. netstat -an—-(TC)命令检查接口73. syncapp——–创建一个公文包74. sysedit——–系统配置编辑器75. sigverif——-文件签名验证程序76. sndrec32——-录音机77. shrpubw——–创建共享文件夹78. secpol.msc—–本地安全策略79. syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码80. services.msc—本地服务设置81. Sndvol32——-音量控制程序82. sfc.exe——–系统文件检查器83. sfc /scannow—windows文件保护84. tsshutdn——-60秒倒计时关机命令3. 84. tsshutdn——-60秒倒计时关机命令85. tourstart——xp简介（安装完成后出现的漫游xp程序）86. taskmgr——–任务管理器87. eventvwr——-事件查看器88. eudcedit——-造字程序89. explorer——-打开资源管理器90. packager——-对象包装程序91. perfmon.msc—-计算机性能监测程序92. progman——–程序管理器93. regedit.exe—-注册表94. rsop.msc——-组策略结果集95. regedt32——-注册表编辑器96. rononce -p —-15秒关机97. regsvr32 /u .dll—-停止dll文件运行98. regsvr32 /u zipfldr.dll——取消ZIP支持99. cmd.exe——–CMD命令提示符100. chkdsk.exe—–Chkdsk磁盘检查101. certmgr.msc—-证书管理实用程序102. calc———–启动计算器103. charmap——–启动字符映射表104. cliconfg——-SQL SERVER 客户端网络实用程序105. Clipbrd——–剪贴板查看器106. conf———–启动netmeeting107. compmgmt.msc—计算机管理108. cleanmgr——-垃圾整理109. ciadv.msc——索引服务程序110. osk————打开屏幕键盘111. odbcad32——-ODBC数据源管理器112. oobe/msoobe /a—-检查XP是否激活113. lusrmgr.msc—-本机用户和组114. logoff———注销命令115. iexpress——-木马捆绑工具，系统自带116. Nslookup——-IP地址侦测器117. fsmgmt.msc—–共享文件夹管理器118. utilman——–辅助工具管理器119. gpedit.msc—–组策略120. explorer——-打开资源管理器","categories":[{"name":"其他奇奇怪怪的","slug":"其他奇奇怪怪的","permalink":"http://yoursite.com/categories/其他奇奇怪怪的/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"java调用cmd编译(二)","slug":"java调用cmd编译C文件(二)","date":"2017-02-05T02:21:51.000Z","updated":"2017-02-05T02:56:52.629Z","comments":true,"path":"2017/02/05/java调用cmd编译C文件(二)/","link":"","permalink":"http://yoursite.com/2017/02/05/java调用cmd编译C文件(二)/","excerpt":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。","text":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 如何使用Java来编译运行C文件(二)前言码农的小日子过得好好的，指导老师一个兴起要求搞一个自己的在线编译网站，我们这种做小弟的只能老老实实地去搞。还好刚刚结束了考试与比赛，因为各种原因导致原定于寒假开工的项目延迟到下学期了，刚好趁这段空闲的时间来搞一搞。其实，自己感觉搞这个的话也挺好玩的~ 介绍利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 开始动工批处理文件先填补上一篇博文剩下的坑。稍微解释一下情景，我想要cd到E盘，然后调用gcc来编译.c文件，可惜搜索借用网上关于使用&amp;&amp;来连接多条cmd语句不能成功，暂时我只想到利用批处理文件来实现这个功能了。123后缀名为.bat的文件，会被系统自动编译为批处理文件。*.bat 文件中输入，就相当于在dos 窗口中输入一样， 编辑完成后，双击即可运行。临时变量：在批处理文件 中设置临时变量方式：`set 变量名=变量值`， = 左右不要有空格，使用方式： %变量名% 即可。批处理文件执行完之后，窗口会自动关闭；若想执行完之后，窗口不自动关闭的话，在文件末尾添加 pause 即可。 调用批处理文件来实现编译1234Runtime run = Runtime.getRuntime();String filePath = \"bat文件绝对地址\";Process p = run.exec(\"cmd.exe /c \" + filePath);//这样子就实现了java调用执行多条cmd语句 编译C源文件将.bat文件与.c文件放于同一目录之下，调用Runtime.getRuntime().exec()来执行编译功能。对于编译来说，只要是获取有可能的错误提示，通过不断接收我们开启的进程的getErrorStream()来获得编译的错误提示。注意，这里没有涉及到我们构建的进程(会有三条不同的流：标准输入流、标准输出流、错误输入流)多条流之间的交互关系，所以理论上不需要使用waitFor()来获取结果。但在运行过程中就不得不使用这个方法来堵塞进程。waitFor()容易导致死锁的发生！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 static Process c; /** * 通过 Runtime 调用批处理文件来编译编源文件 * 注意：批处理文件需要与编译源文件位于同一目录下 * @param filePath 批处理文件的绝对路径 * @throws FileNotFoundException 找不到 */ static public void compileApplication(String filePath) throws FileNotFoundException &#123; Runtime run = Runtime.getRuntime(); String cPath = filePath.replace(\"bat\", \"c\"); File batFile = new File(filePath); File cFile = new File(cPath); if(!cFile.exists())&#123; throw new FileNotFoundException(\"找不到c编译源文件！\"); &#125; if(batFile.exists()) &#123; try &#123; c = run.exec(\"cmd.exe /c \" + filePath); InputStream in = c.getInputStream(); BufferedInputStream errorIn = new BufferedInputStream(c.getErrorStream()); int ch; StringBuffer errortext = new StringBuffer(\"\"); //如果有编译错误，读取错误提示 while ((ch = errorIn.read()) != -1) &#123; errortext.append((char) ch); &#125; //将编译错误打印出来,并抛出错误异常 if (!errortext.equals(\"\")) &#123; System.out.println(errortext); //自定义错误异常 &#125; errorIn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (c != null) &#123; c.destroy(); &#125; &#125; &#125; else &#123; throw new FileNotFoundException(\"找不到cmd批处理文件！\"); &#125; &#125; 如果编译失败时，我们就能从errortext中拿到编译失败提示： 运行exe文件上面一小节已经介绍了，如何编译一个C源文件。对一个编译功能来说，我们只要得到他的错误提示就行了，所以只是一直读取进程的错误信息。但运行一个exe文件时，我们不仅要往进程中输入参数、读取进程的标准输出和错误输出。现在，我们就要了解到进程的waitFor()函数。 通过查看JDK帮助文档，我们可以得知： 1. waitForpublic abstract int waitFor() throws [InterruptedException] 导致当前线程等待，如有必要，一直要等到由该 Process 对象表示的进程已经终止。如果已终止该子进程，此方法立即返回。如果没有终止该子进程，调用的线程将被阻塞，直到退出子进程。返回：进程的出口值。根据惯例，0 表示正常终止。抛出：[InterruptedException] - 如果当前线程在等待时被另一线程中断，则停止等待，抛出 [InterruptedException]。 2. 死锁情况同时，我通过查阅资料了解到：因为本地的系统对标准输入和输出所提供的缓冲池有效，所以错误的对标准输出快速的写入和从标准输入快速的读入都有可能造成子进程的所，甚至死锁。当Runtime对象调用exec()后，JVM会启动一个子进程，该进程会与JVM进程建立三个管道连接：标准输入，标准输出和标准错误流。假设该程序不断在向标准输出流和标准错误流写数据，而JVM不读取的话，当缓冲区满之后将无法继续写入数据，最终造成阻塞在waitFor()这里。为了避免这种情况的发生，我在执行exe文件的一个进程启动四条线程，分别对标准输入、标准输出、标准错误流进行读写，还有一个线程进行时间的控制。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146 static Process p; /** * 过 Runtime 调用运行 exe 文件 * @param filePath exe 文件绝对路径 * @param inputString 程序读取数据 * @throws InterruptedException * @throws FileNotFoundException */ static public void openApplication(String filePath, final String inputString) throws InterruptedException, FileNotFoundException &#123; File file = new File(filePath); if(!file.exists())&#123; throw new FileNotFoundException(\"找不到exe文件！\"); &#125; try &#123; p = Runtime.getRuntime().exec(filePath); //exe程序数据输出流，相当于进程标准输入流 final BufferedInputStream output = new BufferedInputStream(p.getInputStream()); //exe程序数据输入流 final BufferedOutputStream input = new BufferedOutputStream(p.getOutputStream()); //exe程序错误输出流 final BufferedInputStream errorOutput = new BufferedInputStream(p.getErrorStream()); final StringBuffer outputText = new StringBuffer(\"获得信息是: \\n\"); final StringBuffer errorText = new StringBuffer(\"错误信息是：\\n\"); /** * 向线程进行输入 */ new Thread()&#123; public void run()&#123; try &#123; System.out.println(\"执行输入！\\n\"); //将用户输入数据写入 input.write(inputString.getBytes()); input.flush();//清空存缓 System.out.println(\"----\\n读入完毕\\n---\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;.start(); /** * 获得输出的线程 */ new Thread()&#123; public void run()&#123; int ch; try &#123; System.out.println(\"执行输出！\\n\"); //不断获取用户输出 while ((ch = output.read()) != -1) &#123; outputText.append((char) ch); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (output != null)&#123; try &#123; output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;.start(); /** * 获得进程的错误提示 */ new Thread()&#123; public void run()&#123; int ch; try &#123; System.out.println(\"执行错误输出！\\n\"); //不断获取错误输出 while ((ch = errorOutput.read()) != -1) &#123; System.out.println((char) ch); errorText.append((char) ch); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(errorOutput != null)&#123; try &#123; errorOutput.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;.start(); /** * 控制时间的进程 */ Thread timeController = new Thread()&#123; public void run()&#123; try &#123; System.out.println(\"执行时间控制！\\n\"); Thread.sleep(5000); //限制运行时间 //加入错误提示信息 errorText.append(\"\\n运行时间过长！\\n\"); p.destroy(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if(p != null) &#123; p.destroy(); &#125; &#125; &#125; &#125;; timeController.start(); SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式 //记录执行时间 System.out.println(\"\\n开始执行时间：\"+df.format(new Date()));// new Date()为获取当前系统时间 //一直等待直到“启动成功” int retval = p.waitFor(); //waitfor()结束后，关闭时间控制进程 timeController.stop(); //记录结束时间 System.out.println(\"\\n结束执行时间：\"+df.format(new Date()));// new Date()为获取当前系统时间 System.out.println(outputText); System.out.println(errorText); System.out.println(retval); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(p!=null) &#123; p.destroy(); &#125; &#125; &#125; 参考案例https://github.com/FunriLy/OnlineCompilation","categories":[{"name":"其他奇奇怪怪的","slug":"其他奇奇怪怪的","permalink":"http://yoursite.com/categories/其他奇奇怪怪的/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"大学有感","slug":"大学有感","date":"2017-02-02T11:35:54.000Z","updated":"2017-02-05T02:13:14.929Z","comments":true,"path":"2017/02/02/大学有感/","link":"","permalink":"http://yoursite.com/2017/02/02/大学有感/","excerpt":"","text":"“天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。”一直以来很喜欢这句话，一直以来无法全心全意投注于自己专注的事情之中，也一直以来朝着话中的信念前进。 在2015年高考惨遭”滑铁卢战役”，可能一直以来我都处于一种”不服”的观念之中。也正是这种”不服”，我总是尽可能地将我的工作做得更好。正如我朋友曾经对我说过，“你总是那么忙，忙于学习、忙于各种任务……”其实，忙一点，还是不错的。在大学一年半的时间内，我完成了3/6自己订下的目标。到今天，我仍然庆幸自己没有堕落，自己能加入一个能”拼命”的团队(QG)中学习如何与他人合作并且不断提高自己，自己仍然能按照自己选择的道路不断挣扎，虽然累可还是在承受范围内。 大学生活以来没有以前想象中那么高端美好，可每个人多多少少还是会有自己的收获。我想，生活本该如此，该玩的时候玩，该静心的时候静心，该学习的时候学习。大学乃至社会之中，各种形形色色、奇奇怪怪的人，自然有他存在的理由，又何必因为他人而轻易影响到自己？与人合作，只要不影响到我的进度，我可以容纳你的各种想法行为，其实是还未能打动我或者说是懒得理你……这就是我今天总结的”生存之道”。 正所谓，人静而后安，安而能后定，定而嫩=能后慧，慧而能后悟，悟而能后得。 ————《大学》","categories":[{"name":"随记感悟","slug":"随记感悟","permalink":"http://yoursite.com/categories/随记感悟/"}],"tags":[]}]}