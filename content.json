{"meta":{"title":"FunriLySpace","subtitle":"天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。","description":"天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。","author":"FunriLy","url":"https://zggdczfr.cn"},"pages":[{"title":"","date":"2017-02-05T07:31:36.840Z","updated":"2017-02-05T07:31:36.840Z","comments":true,"path":"README.html","permalink":"https://zggdczfr.cn/README.html","excerpt":"","text":"MyBlogMy Personal Website : http://zggdczfr.cnhexo主题 : http://github.com/ppoffice/hexo-theme-icarus"},{"title":"aboutme","date":"2017-02-04T09:49:51.000Z","updated":"2017-02-07T08:59:35.180Z","comments":true,"path":"aboutme/index.html","permalink":"https://zggdczfr.cn/aboutme/index.html","excerpt":"","text":"FunriLy目前就读于广东工业大学计算机学院某系。自己本来就是个半瓢水的逗比。本来语文都没学好，却还要装逼秀英语选择了计算机专业。一阵子折腾下来，只学会了多种编程语言的”Hello Word !”。同时作为一名专业的码农搬砖工，主写JAVA后端，却老是去搞各种奇奇怪怪的东西。生活中，喜欢组织带人去各种浪，浪到天昏地暗，可骨子里却暗藏着2.5次元的宅属性~~~(｡•ˇ‸ˇ•｡) 哼！都怪你们(`ȏ´)也不哄哄人家(〃′o`)人家超想哭的，捶你胸口，大坏蛋！！！ (￣^￣)ゞ咩QAQ 捶你胸口 你好讨厌！(=ﾟωﾟ)ﾉ要抱抱嘤嘤嘤哼，人家拿小锤锤捶你胸口！！！(｡• ︿•̀｡)大坏蛋，打死你(つд⊂)"},{"title":"MY WORKS","date":"2017-02-02T08:33:28.000Z","updated":"2017-02-02T08:33:28.572Z","comments":true,"path":"my_works/index.html","permalink":"https://zggdczfr.cn/my_works/index.html","excerpt":"","text":""},{"title":"TAGS","date":"2017-02-02T08:34:11.000Z","updated":"2017-02-02T08:34:11.760Z","comments":true,"path":"tags/index.html","permalink":"https://zggdczfr.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"让个人域名下GithubPage完美支持https","slug":"让个人域名下GithubPage完美支持https","date":"2017-02-25T12:04:03.000Z","updated":"2017-02-25T12:07:24.297Z","comments":true,"path":"2017/02/25/让个人域名下GithubPage完美支持https/","link":"","permalink":"https://zggdczfr.cn/2017/02/25/让个人域名下GithubPage完美支持https/","excerpt":"欢迎访问完美HTTPS支持的GithubPage个人博客 : https://zggdczfr/","text":"欢迎访问完美HTTPS支持的GithubPage个人博客 : https://zggdczfr/ 让个人域名下GithubPage完美支持https前言最近笔记本挂了送去维修，耽误了我的学习计划，就先把月初的一点小技巧发出来充充数……话说，没了笔记本的日子，看书反而更加认真了~遵从我2016年10月时，定下的目标：于2017年开始要坚持写博客。于是，我在GithubPage上搞了个静态博客网站 https://zggdczfr.cn/ 。作为一个有个性并略有强迫症的程序猿，肯定要给自己的博客弄个个人域名，再配上一把小小的绿锁头。腾讯云专门为大学生推出了服务器和个人域名的优惠政策，鉴于这个域名是去年申请的，虽然不是很有个人特色也只能勉强用着先。 准备 仓库：Github Hexo 博客主题：icarus 评论系统：多说 SSL证书：CloudFlare 个人域名(腾讯云)：https://zggdczfr.cn/ 为什么要使用 HTTPS 协议？ 虽然SSL并不是无懈可击的，但是我们应该尽可能提高窃听成本 加密通讯不应心存侥幸，所有连接都应被加密 福利： 使用了HTTPS之后，如果网站的访客是从其他已经使用了HTTPS的网站上跳转过来，你就能在Google Analytics中获取更完整的来源信息。 不过关于最后一点，我不得不吐槽一下”墙”，它导致 Google Analytics 的信息延迟长达一天以上，最后我不得不退而选择 Baidu Analytics。 在Github上搭建 Hexo 主题博客关于这个我就不罗嗦了，网上一大堆教程，分享一篇非常详细的博客(里面包括了GithubPage应用自定义域名) : https://xuanwo.org/2015/03/26/hexo-intor/不过，绑定后我们只能通过http://域名来访问。如果访问https://XXX.github.io/(即原来的域名)将会被重定向(302)到我们的自定义域名。若直接访问https://域名，浏览器会报SSL_DOMAIN_NOT_MATCHED警告。 CloudFlare 给自己的域名加个 s首先，GitHub Pages不支持上传SSL证书。CloudFlare 是一家CDN提供商，它提供了免费的https服务(但不是应用SSL证书)。实现模式就是，用户到CDN服务器的连接为https，而CDN服务器到GithubPage服务器的连接为http，就是在CDN服务器那里加上反向代理。 注册并登录CloudFlare，并将自己域名下的 name server 修改为 CloudFlare 的 name server。 在 CloudFlare 的 DNS 设置域名匹配到自己的GithubPage(启用动态DNS加速)。 在 CloudFlare 的 Crypto 设置 SSL 为 Flexible(等待一定时间实现建立连接后，就可以通过https来访问自己的 GithubPage )。 在 CloudFlare 的 Page Rules 中设置路由规则。一般情况下，利用Always use https设置两条规则，规则链接分别为http://域名/*与http://域名/(开启https强制跳转)。 关于评论系统如果使用国外的评论系统disqus，这个的确完美支持 https。但，所限于用户限制，也只能舍弃。对于国内的评论系统，主要就是友言(有JS文件支持不了HTTPS引用)，多说(这个默认属性并不支持HTTPS但可以进行改造)。 对”多说”进行了解使用”多说”有一个缺点，他们的服务器不知道为何会偶尔性挂掉。 多说的评论框虽然提供了https链接，但是其中的一些头像和表情还是http的。通过F12，我们可以发现多说的embed.js请求头像和表情的时候用的是http协。但是，这两个链接本身也支持https协议。先给个embed.js的官方下载链接 : https://static.duoshuo.com/embed.js 下载后的JS文件是经过压缩的，所以我们需要用 Sublime Text 来进行格式话，以方便我们阅读。 修改头像链接经过漫长的Debug，我终于找到了头像链接的相应位置。搜索avatar_url找到头像链接(展示其中部分代码)，：1234 var Z = &#123; userUrl: function(e) &#123; return e.url &#125;, avatarUrl: function(e) &#123; return e.avatar_url || rt.data.default_avatar_url &#125;, loginUrl: function(e, t) &#123; 简单的字符串替换为”https”，将其修改为：123456 var Z = &#123; userUrl: function(e) &#123; return e.url &#125;, avatarUrl: function(e) &#123; var s = e.avatar_url || rt.data.default_avatar_url s=s.replace(/http:/g,'https:'); return s &#125;, loginUrl: function(e, t) &#123; 修改表情链接经过Debug，发现传送的属性是meaasge，它的上一个属性是s。最终查了好久之后终于发现了它的位置(这个没有上一个明显)，搜索s = e.post就可以找到它的位置(注意等号旁边的空格)。1234 var t = \"\", s = e.post, i = e.options, r = s.author; 简单的字符串替换为”https”，将其修改为：12345 var t = \"\", s = e.post, i = e.options, r = s.author; s.message = s.message.replace(/http:/g,\"https:\"); 修改表情按钮链接这个最简单了，Debug发现按钮链接为”http://img.t.sinajs.cn/t35/style/images/common/face/ext/normal/“ ，在JS文件中将其修改为 https 即可。 替换embed.js的路径以Hexo主题icarus为例，在themes\\icarus\\layout\\comment文件夹下找到多说的调用ejs文件。我将上面修改过的JS文件放到了主题的资源JS文件夹，然后在相应的ejs文件中修改调用路径即可。123 ds.async = true; ds.src = '/js/embed.js'; ds.charset = 'UTF-8'; 完美应用利用hexo命令hexo g &amp;&amp; hexo d，重新将静态资源pull到Github上。欢迎大家去访问一下我的个人博客 https://www.zggdczfr.cn/ 。 关于图床的问题https引用的图片一直是略微麻烦的事情。 第一种，是将图片放到Github上。但是，使用相对路径引用的话，会出现跳转页面时一些图片路径会错误；使用绝对路径引用的话，会出现重定向的问题，浏览器报302异常，使浏览器上的绿色小锁头不见了(不能容忍……)。 第二种，是将图片放到七牛云上面，不过注册用户每个月有流量限制，我担心若访问人数太多(虽然不大可能)会使图片失效。 第三种，从知乎上找到了支持 https 的图床，虽然不知道能使用多久(我现在也就是使用这种)。给个链接 : https://www.tuchuang001.com/ 第四种，在自己的私人服务器上搭一个(因为自己的腾讯云服务器要经常做一些测试，就不选择放到上面了)。","categories":[{"name":"其他奇奇怪怪的","slug":"其他奇奇怪怪的","permalink":"https://zggdczfr.cn/categories/其他奇奇怪怪的/"}],"tags":[{"name":"https","slug":"https","permalink":"https://zggdczfr.cn/tags/https/"}]},{"title":"Spring Cloud Config(续)","slug":"Spring-Cloud-Config-续","date":"2017-02-21T12:17:49.000Z","updated":"2017-02-21T12:21:54.528Z","comments":true,"path":"2017/02/21/Spring-Cloud-Config-续/","link":"","permalink":"https://zggdczfr.cn/2017/02/21/Spring-Cloud-Config-续/","excerpt":"","text":"Spring Cloud Config(续)个人参考项目个人博客 : https://zggdczfr.cn/个人参考项目 : （整合到上一个案例中）https://github.com/FunriLy/springcloud-study/tree/master/%E6%A1%88%E4%BE%8B5 为 Config Client 配置配置刷新场景介绍在上一个案例，我们成功配置了 Config Server 与 Config Client。依次启动两个项目。 访问API接口 http://localhost:1111/config 来获取配置信息： 1The Config Word Is : Hello World ! 利用 Git 提交我们修改后配置文件。 重新访问API接口 http://localhost:1111/config 来获取配置信息： 1The Config Word Is : Hello World ! 由此可见，配置资源的更新不能即时通知到 Server Client。 实现配置文件更新 引入依赖 12345&lt;!-- actuator 监控 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 在 Controller层加入注解@RefreshScope如果 @Controller 是加在单独的类中声明的（不是在Application启动类上声明）。那么@RefreshScope要加在声明@Controller声明的类上，否则refresh之后Conroller拿不到最新的值，会默认调用缓存。 通过POST请求发送到 http://localhost:1111/refresh ，我们可以看到以下内容： 123[ \"configword\"] 重新访问API接口 http://localhost:1111/config 来获取配置信息： 1The Config Word Is : NewConfig !","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/tags/spring-cloud/"}]},{"title":"Spring Cloud Config","slug":"Spring-Cloud-Config","date":"2017-02-20T12:45:14.000Z","updated":"2017-02-20T12:49:33.984Z","comments":true,"path":"2017/02/20/Spring-Cloud-Config/","link":"","permalink":"https://zggdczfr.cn/2017/02/20/Spring-Cloud-Config/","excerpt":"Spring Cloud Config配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。","text":"Spring Cloud Config配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。 Spring Cloud Config 参考个人项目参考个人项目 : (希望大家能给个star~)https://github.com/FunriLy/springcloud-study/tree/master/%E6%A1%88%E4%BE%8B5 什么是 Spring Cloud Config？配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion。场景介绍：在一个 Application 中，很经常需要连接资源和其它应用,经常有很多需要外部设置的信息去调整Application行为。我们在实际开发应用中的会经常见到的xml、properties、yaml等就是配置信息，但这种做法有一定的缺陷：每次更新需要重新打包和重启。 创建 Spring Cloud Config Server(Git 存储) 这里我用了我原本的”服务注册中心”(Eureka Server)，将其改造为”配置中心”(Config Server)。 引入依赖 12345 &lt;!-- Config Server --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; 在启动主类添加@EnableConfigServer注解，开启 Config Server。 12345678@SpringBootApplication@EnableEurekaServer@EnableConfigServerpublic class MySpringCloudApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MySpringCloudApplication.class, args); &#125;&#125; 在Github上创建一个项目，并在其中添加配置文件 config-client.properties，在里面添加一个属性config=hello world !。 在application.properties中配置服务信息以及git信息(这里不包括了 Eureka Server 的配置，自行补充) 12345server.port=8761spring.cloud.config.server.git.uri=https://github.com/FunriLy/springcloud-study/spring.cloud.config.server.git.searchPaths=config-repospring.cloud.config.server.git.username=Usernamespring.cloud.config.server.git.password=Password 启动工程 Config Server。访问 http://localhost:8761/config-client/default/ (关于这个URL请参考附录)，可以看到以下配置信息： 12345678910111213141516&#123; \"name\": \"config-client\", \"profiles\": [ \"default\" ], \"label\": null, \"version\": \"af7ce2a15dcdea9dab42e6b44d37e401072382d8\", \"propertySources\": [ &#123; \"name\": \"https://github.com/FunriLy/springcloud-study/config-repo/config-client.properties\", \"source\": &#123; \"configword\": \"hello world !\" &#125; &#125; ]&#125; 创建一个Spring Cloud Config Client 这里我用到了原来的”服务提供者”(Eureka Client)，将其改造为 Config Client。 在resource下创建bootstrap.properties,并设置信息,具体如下: 1234spring.application.name=config-clientspring.cloud.config.profile=defaultspring.cloud.config.label=masterspring.cloud.config.uri=http://localhost:8761/ 注意这里是bootstrap.properties而不是appliction.properties。因为bootstrap.properties会在应用启动之前读取,而spring.cloud.config.uri会影响应用启动 创建一个Controller来进行测试。 1234567891011@RestControllerpublic class ConfigController &#123; @Value(\"$&#123;configword&#125;\") String configword; @RequestMapping(\"/config\") public String printfConfig()&#123; return \"The Config Word Is : \"+configword; &#125;&#125; 启动 Config Client，访问 http://localhost:1111/config 。就能看到： 1The Config Word Is : hello world ! 附录来源于 Spring Cloud Config 中文文档。 URL与配置文件的映射关系 /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties application是SpringApplication的spring.config.name，(一般来说’application’是一个常规的Spring Boot应用)，profile是一个active的profile(或者逗号分隔的属性列表)，label是一个可选的git标签(默认为”master”)。比如，我的文件名是”config-client”，一般在Github上都是default环境，默认为master分支。所以就是/config-client/default/master Config Server 配置文件 spring.cloud.config.server.git.uri：配置git仓库位置 spring.cloud.config.server.git.searchPaths：配置仓库路径下的相对搜索位置，可以配置多个 spring.cloud.config.server.git.username：访问git仓库的用户名 spring.cloud.config.server.git.password：访问git仓库的用户密码 Config Client 配置文件 spring.application.name：对应前配置文件中的{application}部分 spring.cloud.config.profile：对应前配置文件中的{profile}部分 spring.cloud.config.label：对应前配置文件的git分支 spring.cloud.config.uri：配置中心的地址 参考资料 (SpringCloud 中文官网)https://springcloud.cc/ (Spring Cloud Config)https://springcloud.cc/spring-cloud-config-zhcn.html (大神DD)http://blog.didispace.com/springcloud4/ 其他在Config Server中,还有一种不使用Git的”native”的配置方式,这种方式是从本地classpath 或文件系统中加载配置文件(使用 “spring.cloud.config.server.native.searchLocations”配置项进行设置)。 加载Config Server 的”spring.profiles.active=native”配置项可以开启native配置。如:12spring.profiles.active=nativespring.cloud.config.server.native.searchLocations=file:D:/properties 注意 : 牢记使用file:前缀来指示资源(默认没有前缀是从classpath中去文件)。也可以嵌入${}环境参数占位符，但是windows系统下使用绝对路径，前缀后面需要多加个”/“。","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/tags/spring-cloud/"}]},{"title":"断路器 Hystrix","slug":"断路器-Hystrix","date":"2017-02-19T13:18:06.000Z","updated":"2017-02-19T13:20:46.765Z","comments":true,"path":"2017/02/19/断路器-Hystrix/","link":"","permalink":"https://zggdczfr.cn/2017/02/19/断路器-Hystrix/","excerpt":"Spring Cloud Netflix Hystrix是分布式系统处理超时和错误的机制。当某个微服务发生故障时，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。","text":"Spring Cloud Netflix Hystrix是分布式系统处理超时和错误的机制。当某个微服务发生故障时，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。 断路器 Hystrix断路器模式 (云计算设计模式)断路器模式源于Martin Fowler的Circuit Breaker一文。在分布式环境中，其中的应用程序执行访问远程资源和服务的操作，有可能对这些操作的失败是由于瞬时故障，如慢的网络连接，超时，或者被过度使用的资源或暂时不可用。这些故障一般之后的短时间内纠正自己。所谓的断路器模式，就是当某个微服务发生故障时，通过断路器的故障监控，向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。（来源于网上资料） 什么是 Hystrix？Spring Cloud Netflix Hystrix是分布式系统处理超时和错误的机制。其服务失效判断阈值为 : 在Hystrix里默认是5秒内20个失败。 正常的分布式系统架构图(来源于Hystri官方文档)如下 : 若其中一个服务挂掉之后可能会导致其他调用业务服务的线程大量堵塞，最终导致整个系统瘫痪。Hystrix 允许开发人员提供错误提示信息并开启一个路由回调。如图(来源于Hystri官方文档) : 通过 Feign 使用 HystriFeign中已经依赖了Hystrix，所以我们直接调用即可，不必加入 Hystri 依赖。在上一次的 Fegin 工程中使用 Hystri。 创建回调类并实现调用接口类 12345678@Componentpublic class ServiceClientHystrix implements ServiceClient &#123; @Override public String printf() &#123; return \"断路器 : 回调函数\"; &#125;&#125; 使用@FeignClient注解中的fallback属性指定回调类 1234567@Component@FeignClient(value = \"my-service\", fallback = ServiceClientHystrix.class)public interface ServiceClient &#123; @RequestMapping(\"/service\") String printf();&#125; 为了能够看到回调效果，我们设置 Hystri 的超时时间为1毫秒。在 application.properties添加属性： 1hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=1 依次启动”服务注册中心”、”服务提供者”、”服务消费者(Feign版)”，连续多次访问 http://localhost:2222/test 。 添加 Hystrix Dashboard 监控 添加依赖 123456789&lt;!-- Hystrix Dashboard 监控 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类添加启动注解@EnableHystrixDashboard 再次启动”服务消费者”，访问 http://localhost:2222/hystrix 在URL中输入监控URL : http://localhost:2222/hystrix.stream 同时多次访问 http://localhost:2222/test 并观察监控仪表板的变化。 发现的问题 问题描述：Fegin第一次启动请求失败？ 问题原因：首次请求往往会比较慢（Spring的懒加载机制，需要实例化一些类），因此请求时间往往大于 Hystrix 的默认超时时间(1秒)。 解决方法：延长 Hystrix 的超时时间1234/** * default 是默认所有请求；具体某个请求则修改 default 为相应的访问即可 */hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 5000 参考资料 https://github.com/Netflix/Hystrix/wiki https://springcloud.cc/spring-cloud-netflix-zhcn.html#true-circuit-breaker-hystrix-clients http://blog.didispace.com/springcloud3/ http://www.itmuch.com/spring-cloud-feign-ribbon-first-request-fail/ 个人参考项目个人参考项目 : https://github.com/FunriLy/springcloud-study/tree/master/%E6%A1%88%E4%BE%8B4","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/tags/spring-cloud/"}]},{"title":"Fegin的使用","slug":"Fegin的使用","date":"2017-02-18T13:03:01.000Z","updated":"2017-02-19T13:19:14.433Z","comments":true,"path":"2017/02/18/Fegin的使用/","link":"","permalink":"https://zggdczfr.cn/2017/02/18/Fegin的使用/","excerpt":"Feign : Declarative REST clients，是一个声明web服务客户端。Spring Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign。","text":"Feign : Declarative REST clients，是一个声明web服务客户端。Spring Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign。 Feign 的使用什么是Feign？Feign : Declarative REST clients。Feign 是一个声明web服务客户端，这便得编写web服务客户端更容易，使用 Feign 创建一个接口并对它进行注解，它具有可插拔的注解支持包括Feign注解与JAX-RS注解，Feign还支持可插拔的编码器与解码器，Spring Cloud 增加了对 Spring MVC的注解，Spring Web 默认使用了HttpMessageConverters, Spring Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign。(来源于Spring Cloud Netflix 官网文档) Feign 在 github 上的开源文档 : https://github.com/OpenFeign/feign/wiki 怎么使用Feign首先继续使用上次的”服务注册中心”与”服务提供者”。接下来，就是将 Fegin 整合到”服务消费者”中。 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt; 注入注解在 Spring Boot 主类加入注解@EnableFeignClients开启 Fegin 功能。 注入接口创建接口，具体如下：1234567@Component@FeignClient(value = \"my-service\")public interface ServiceClient &#123; @RequestMapping(\"/service\") String printf();&#125; 使用@Component注解向 Spring Boot 中注入该组件。 使用@FeignClient(&quot;&quot;)注解来绑定该接口对应的服务 通过 Spring MVC 的注解来配置服务下的具体实现。 在Controller中调用接口1234567891011@RestControllerpublic class ConsumerController &#123; @Autowired private ServiceClient serviceClient; @RequestMapping(\"/test\") public String test()&#123; return serviceClient.printf(); &#125;&#125; 最后，启动”注册中心”、”服务提供者”、”服务消费者”等工程。访问 http://localhost:2222/test 就可以在”服务提供者”控制台查看到负载均衡的实现。 注意事项注意注意注意当Spring Cloud版本为 Brixton.RELEASE ，会抛出异常： Attribute ‘value’ in annotation [org.springframework.cloud.netflix.feign.FeignClient] must be declared as an @AliasFor [serviceId], not [name] 解决办法：将Spring Cloud版本改为 Brixton.SR5 或 Camden.RELEASE 即可。 参考资料 (大神DD的博客)http://blog.didispace.com/springcloud2/ (官方文档中文译本)https://springcloud.cc/spring-cloud-netflix-zhcn.html#spring-cloud-feign 个人参考项目个人参考项目 : https://github.com/FunriLy/springcloud-study/tree/master/%E6%A1%88%E4%BE%8B3","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/tags/spring-cloud/"}]},{"title":"使用Ribbon实现客户端的负载均衡","slug":"使用Ribbon实现客户端的负载均衡","date":"2017-02-13T10:54:08.000Z","updated":"2017-02-19T13:20:48.408Z","comments":true,"path":"2017/02/13/使用Ribbon实现客户端的负载均衡/","link":"","permalink":"https://zggdczfr.cn/2017/02/13/使用Ribbon实现客户端的负载均衡/","excerpt":"Spring Cloud Netflix Ribbon 是一个客户端负载均衡的组件。Ribbon的特点 和Eureka完美整合 支持多种协议-HTTP,TCP,UDP 缓存/批处理 built in failure resiliency","text":"Spring Cloud Netflix Ribbon 是一个客户端负载均衡的组件。Ribbon的特点 和Eureka完美整合 支持多种协议-HTTP,TCP,UDP 缓存/批处理 built in failure resiliency 使用Ribbon实现客户端的负载均衡RibbonSpring Cloud Netflix Ribbon 是一个客户端负载均衡的组件。 Ribbon的特点 和Eureka完美整合 支持多种协议-HTTP,TCP,UDP 缓存/批处理 built in failure resiliency 具体请查看官方文档 ： https://github.com/Netflix/ribbon/wiki 整合Ribbon实现客户端的负载均衡前期准备这里用到了上次的两个demo(服务注册中心和服务提供者)。首先，添加服务提供者的服务，这里我将其端口号打印出来能够更加直观地观察到负载均衡的实现：123456789101112@RestControllerpublic class PrintfController &#123; @Value(\"$&#123;server.port&#125;\") private String port; @RequestMapping(\"/service\") public String printf()&#123; System.out.println(\"服务消费者正在使用服务，端口号为 : \"+port); return \"success\"; &#125;&#125; 接下来分别启动这两个工程，注意将服务提供者的端口号(原来为1111改为1112)修改后再启动一次.就整个项目而言，总共有三个微服务再运行着(一个注册中心，两个服务提供者)。PS:其实服务提供者你想弄多少都行。 创建服务消费者像一个普通的 spring cloud 工程一样，创建后向注册中心注册自己的信息。添加依赖:1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;&lt;/dependency&gt; 添加消费调用接口：这里涉及到一个类LoadBalancerClient，这个就是由 Netflix Ribbon 提供的工具类。他会根据 ServiceId （配置文件中的Service Name）向 Eureka （注册服务器）获取服务地址。1234567891011121314@RestControllerpublic class ConsumerController &#123; @Autowired private LoadBalancerClient client; @RequestMapping(\"/test\") public String test()&#123; ServiceInstance instance = client.choose(\"service\"); URI uri = instance.getUri(); System.out.println(uri); return (new RestTemplate()).getForObject(uri+\"/service\",String.class); &#125;&#125; 配置文件信息：1234# eureka client 配置spring.application.name=ribbon-consumerserver.port=2222eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/ 注意：LoadBalancerClient返回的是已经注册的服务器地址。 启动服务消费者启动工程后，我们可以看到如下注册信息： Ribbon 实现负载均衡多次访问 http://localhost:2222/test ，并查看控制台信息： 参考资料： Spring Cloud Netflix 官网文档-中文译本 Spring Cloud Netflix Ribbon 个人参考项目个人参考项目 : https://github.com/FunriLy/springcloud-study/tree/master/%E6%A1%88%E4%BE%8B2","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/tags/spring-cloud/"}]},{"title":"Eureka 学习笔记","slug":"Eureka-学习笔记","date":"2017-02-11T08:48:20.000Z","updated":"2017-02-19T13:18:38.931Z","comments":true,"path":"2017/02/11/Eureka-学习笔记/","link":"","permalink":"https://zggdczfr.cn/2017/02/11/Eureka-学习笔记/","excerpt":"Eureka是Netflix开发的服务发现组件，本身是一个基于REST的服务。Spring Cloud将它集成在其子项目spring-cloud-netflix中，以实现Spring Cloud的服务发现功能。在Spring Cloud中，将会使用 Eureka 作为发现服务，所以了解 Eureka 是非常重要的。","text":"Eureka是Netflix开发的服务发现组件，本身是一个基于REST的服务。Spring Cloud将它集成在其子项目spring-cloud-netflix中，以实现Spring Cloud的服务发现功能。在Spring Cloud中，将会使用 Eureka 作为发现服务，所以了解 Eureka 是非常重要的。 关于 Eureka 的学习笔记前言Eureka是Netflix开发的服务发现组件，本身是一个基于REST的服务。Spring Cloud将它集成在其子项目spring-cloud-netflix中，以实现Spring Cloud的服务发现功能。在Spring Cloud中，将会使用 Eureka 作为发现服务，所以了解 Eureka 是非常重要的。因此做了一下翻译以及学习笔记记录。Eureka的Github：https://github.com/Netflix/Eureka Eureka 笔记什么是 Eureka？Eureka 是基于 REST(Representational State Transfer)服务。主要用于AWS云中的定位/发现服务，从而实现对于中间层服务器的负载均衡(Load Balance)和故障切换(failover)。同时，Eureka 还提供了一个基于JAVA的客户端组件(Eurake Client)，便于与Eureka Server进行交互。在客户端中，同样内置了负载均衡，用于执行基本的负载均衡轮询制度。而 Netflix 将它们集合成一个更加负载的负载均衡器，通过对流量、资源使用等因素，提供了更加合理的加权负载均衡策略服务。Eureka 具有心跳检测、健康检查和客户端缓存等多种机制提高了服务系统的灵活性。 什么是AWS云？对于AWS云，可以参考一下这篇博文 http://blog.csdn.net/awschina/article/details/17639191感觉 Eureka 就是为了提供对于 AWS云服务 的补充(中间层负载均衡)。 什么是中间层(Middle Tier)？上面老是提到了中间层(Middle Tier)。中间层 (Middle Tier)也称作“应用程序服务器层或应用服务层”，是用户接口或 Web 客户端与数据库之间的逻辑层。典型情况下 Web 服务器位于该层，业务对象在此实例化。(来源于百度百科) Eureka 目的/优点 中间层的负载均衡 使用 Netflix 的红/黑部署(red/black deployments)，使开发者更加容易实现云部署 对于 cassandra deployments，方便于对实例化后的对象维护 利用 memcached 提供缓存服务(Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。)。 可配置性/动态配置。使用Eureka，可以即时添加或删除群集节点；Eureka使用archaius(Netflix开源的配置管理类):如果你有一个配置源实现，这些配置可以进行动态调整应用。 Eureka 最大的特性Eureka 集群服务具有极大的”弹性”(Resilience)。这个是我认为它最大的特点。 Eureka Client 处理一个或多个Eureka服务器的故障。 由于 Eureka Client 在其中具有注册表缓存信息，因此即使所有 Eureka Servers 都关闭，它们还是可以很好地运行。 Eureka Servers 即使在其他 Eureka 挂了也具有极大的”弹性”。既是是在 Client 与 Server 的网络分裂(network partition)期间，Eureka Server 具有的内部弹性特性也能防止大规模服务中断。 Eureka Server 与 Client 之间的通信Eureka 只是找到有关客户端与之通信的服务器的信息，但不对通信的协议或方法施加任何限制。通常情况下，我们可以使用 Eureka 获取目标服务器地址，并使用thrift，http(s)或任何其他RPC机制等协议来进行交互通信。 Eureka 架构接下来，对其中的名词进行解释： Application Service 相当于服务提供者 Application Client 相当于服务消费者 Make Remote Call，其实就是实现服务的使用 us-east-1 其实实现了Eurake 集群服务 us-east-1c、us-east-1d、us-east-1e 就是集群服务中的某个具体实现区域(感觉找不到一个合适的词来解释这种抽象的概念) Eureka 架构机制我们的 Eureka 集群服务其实就是靠 Server 与 Client 之间的交互来实现的。 前面说过，Eureka Server 具有服务定位/发现的能力，在各个微服务启动时，会通过Eureka Client向Eureka Server进行注册自己的信息（例如网络信息）。 一般情况下，微服务启动后，Eureka Client 会周期性向 Eureka Server 发送心跳检测(默认周期为30秒)以注册/更新自己的信息。 如果 Eureka Server 在一定时间内(默认90秒)没有收到 Eureka Client 的心跳检测，就会注销掉该微服务点。 同时，Eureka Server 它本身也是 Eureka Client，多个 Eureka Server 通过复制注册表的方法来完成服务注册表的同步从而达到集群的效果 参考资料 https://github.com/Netflix/eureka/wiki","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/tags/spring-cloud/"}]},{"title":"初学 Spring Cloud","slug":"初学Spring Cloud","date":"2017-02-10T02:44:20.000Z","updated":"2017-02-20T12:49:36.162Z","comments":true,"path":"2017/02/10/初学Spring Cloud/","link":"","permalink":"https://zggdczfr.cn/2017/02/10/初学Spring Cloud/","excerpt":"在SpringBoot的坑还没填完的情况下，我又迫不及待地开新坑了。主要是寒假即将结束了，到时又得忙于各种各样的事情……留个坑给自己应该就会惦记着它，再慢慢地补上…………………………SpringCloud,我来啦hhhhhhhh~","text":"在SpringBoot的坑还没填完的情况下，我又迫不及待地开新坑了。主要是寒假即将结束了，到时又得忙于各种各样的事情……留个坑给自己应该就会惦记着它，再慢慢地补上…………………………SpringCloud,我来啦hhhhhhhh~ 初学SpringCloudSpringCloud 介绍Spring Cloud是一个基于Spring Boot实现的云应用开发工具(就是说，接触Spring Cloud之前需要了解一下Spring Boot)。归结起来，Spring Cloud 是一个微服务工具包，为开发者提供了在分布式系统的配置管理、服务发现、断路器、智能路由、微代理、控制总线等许多开发工具包。按照官方的说法就是，Spring Cloud 为开发者提供了在分布式系统操作的工具。而且容易上手，可以进行快速开发。 微服务架构微服务架构概念“微服务架构”，就是将一个完整的应用从数据存储开始拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展。系统中的各个微服务可被独立部署，各个微服务之间是松耦合的。每个微服务仅关注于完成一件任务并很好地完成该任务。服务与服务间通过诸如RESTful API的方式互相调用。 关于微服务架构的扯淡“微服务架构”，其实这个概念好几年前就已经出现了，而且国外也出现了较为成熟的产品：netflix、dubbo等。听说目前 Spring 开发团队的精力主要集中于 spring boot 和 spring cloud 相关框架的开发。一般情况下，作为一个学习 java 的屌丝，基本上跟上 spring 屌丝的步伐，也就跟上了主流技术。 微服务架构的选择附上大神 程序猿DD(翟永超) 的一篇博客，可以参考一下：微服务架构的基础框架选择：Spring Cloud还是Dubbo？ 服务注册与发现(Eureka)Eureka Server 创建一个 Spring Boot 项目。只要引入了Log4j2，便于日志记录。pom.xml依赖文件如下:1234567891011121314151617181920212223242526 &lt;!-- SpringBoot 框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--log4j2--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- eureka-服务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; 版本参数:123456789101112131415161718192021 &lt;!-- 还是比较喜欢稳定的 Brixton 版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Brixton.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--spring boot 的 maven 插件--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 通过@EnableEurekaServer注解启动一个服务注册中心。直接在SpringBoot启动类加上注解@EnableEurekaServer即可。 application.properties配置: 1234server.port=8761eureka.client.register-with-eureka=falseeureka.client.fetch-registry=falseeureka.client.serviceUrl.defaultZone=http://localhost:$&#123;server.port&#125;/eureka/ 同时，简要说明一下这些配置项：eureka.client.registerWithEureka ：表示是否将自己注册到Eureka Server，默认为true。由于当前这个应用就是Eureka Server，故而设为false。eureka.client.fetchRegistry ：表示是否从Eureka Server获取注册信息，默认为true。因为这是一个单点的Eureka Server，不需要同步其他的Eureka Server节点的数据，故而设为false。eureka.client.serviceUrl.defaultZone ：设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。 启动工程，访问 http://localhost:8761/ 。如图所示: Eureka Client 创建一个 Spring Boot 项目。基本上与上一个工程无异，pom.xml需要修改了一个依赖。 12345 &lt;!-- eureka-服务 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; 通过@EnableDiscoveryClient注解启动一个服务注册中心。直接在SpringBoot启动类加上注解@EnableDiscoveryClient即可。同时，Eureka Client 提供的服务与一般 Spring Boot 项目是一样的。 application.properties配置:这些配置参数还是比较容易理解的。 1234# eureka client 配置spring.application.name=service0server.port=1111eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka/ 启动两个工程，并访问 Eureka Server 中心 http://localhost:8761/ 。如图所示: 附录个人参考项目 : https://github.com/FunriLy/springcloud-study/tree/master/%E6%A1%88%E4%BE%8B1 参考资料 (Spring Cloud Netflix) https://springcloud.cc/spring-cloud-netflix-zhcn.html","categories":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/categories/spring-cloud/"}],"tags":[{"name":"spring cloud","slug":"spring-cloud","permalink":"https://zggdczfr.cn/tags/spring-cloud/"}]},{"title":"java调用cmd编译(二)","slug":"java调用cmd编译C文件(二)","date":"2017-02-05T02:21:51.000Z","updated":"2017-02-18T13:14:17.308Z","comments":true,"path":"2017/02/05/java调用cmd编译C文件(二)/","link":"","permalink":"https://zggdczfr.cn/2017/02/05/java调用cmd编译C文件(二)/","excerpt":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。","text":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 如何使用Java来编译运行C文件(二)前言码农的小日子过得好好的，指导老师一个兴起要求搞一个自己的在线编译网站，我们这种做小弟的只能老老实实地去搞。还好刚刚结束了考试与比赛，因为各种原因导致原定于寒假开工的项目延迟到下学期了，刚好趁这段空闲的时间来搞一搞。其实，自己感觉搞这个的话也挺好玩的~ 介绍利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 开始动工批处理文件先填补上一篇博文剩下的坑。稍微解释一下情景，我想要cd到E盘，然后调用gcc来编译.c文件，可惜搜索借用网上关于使用&amp;&amp;来连接多条cmd语句不能成功，暂时我只想到利用批处理文件来实现这个功能了。123后缀名为.bat的文件，会被系统自动编译为批处理文件。*.bat 文件中输入，就相当于在dos 窗口中输入一样， 编辑完成后，双击即可运行。临时变量：在批处理文件 中设置临时变量方式：`set 变量名=变量值`， = 左右不要有空格，使用方式： %变量名% 即可。批处理文件执行完之后，窗口会自动关闭；若想执行完之后，窗口不自动关闭的话，在文件末尾添加 pause 即可。 调用批处理文件来实现编译1234Runtime run = Runtime.getRuntime();String filePath = \"bat文件绝对地址\";Process p = run.exec(\"cmd.exe /c \" + filePath);//这样子就实现了java调用执行多条cmd语句 编译C源文件将.bat文件与.c文件放于同一目录之下，调用Runtime.getRuntime().exec()来执行编译功能。对于编译来说，只要是获取有可能的错误提示，通过不断接收我们开启的进程的getErrorStream()来获得编译的错误提示。注意，这里没有涉及到我们构建的进程(会有三条不同的流：标准输入流、标准输出流、错误输入流)多条流之间的交互关系，所以理论上不需要使用waitFor()来获取结果。但在运行过程中就不得不使用这个方法来堵塞进程。waitFor()容易导致死锁的发生！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 static Process c; /** * 通过 Runtime 调用批处理文件来编译编源文件 * 注意：批处理文件需要与编译源文件位于同一目录下 * @param filePath 批处理文件的绝对路径 * @throws FileNotFoundException 找不到 */ static public void compileApplication(String filePath) throws FileNotFoundException &#123; Runtime run = Runtime.getRuntime(); String cPath = filePath.replace(\"bat\", \"c\"); File batFile = new File(filePath); File cFile = new File(cPath); if(!cFile.exists())&#123; throw new FileNotFoundException(\"找不到c编译源文件！\"); &#125; if(batFile.exists()) &#123; try &#123; c = run.exec(\"cmd.exe /c \" + filePath); InputStream in = c.getInputStream(); BufferedInputStream errorIn = new BufferedInputStream(c.getErrorStream()); int ch; StringBuffer errortext = new StringBuffer(\"\"); //如果有编译错误，读取错误提示 while ((ch = errorIn.read()) != -1) &#123; errortext.append((char) ch); &#125; //将编译错误打印出来,并抛出错误异常 if (!errortext.equals(\"\")) &#123; System.out.println(errortext); //自定义错误异常 &#125; errorIn.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (c != null) &#123; c.destroy(); &#125; &#125; &#125; else &#123; throw new FileNotFoundException(\"找不到cmd批处理文件！\"); &#125; &#125; 如果编译失败时，我们就能从errortext中拿到编译失败提示： 运行exe文件上面一小节已经介绍了，如何编译一个C源文件。对一个编译功能来说，我们只要得到他的错误提示就行了，所以只是一直读取进程的错误信息。但运行一个exe文件时，我们不仅要往进程中输入参数、读取进程的标准输出和错误输出。现在，我们就要了解到进程的waitFor()函数。 通过查看JDK帮助文档，我们可以得知： 1. waitForpublic abstract int waitFor() throws [InterruptedException] 导致当前线程等待，如有必要，一直要等到由该 Process 对象表示的进程已经终止。如果已终止该子进程，此方法立即返回。如果没有终止该子进程，调用的线程将被阻塞，直到退出子进程。返回：进程的出口值。根据惯例，0 表示正常终止。抛出：[InterruptedException] - 如果当前线程在等待时被另一线程中断，则停止等待，抛出 [InterruptedException]。 2. 死锁情况同时，我通过查阅资料了解到：因为本地的系统对标准输入和输出所提供的缓冲池有效，所以错误的对标准输出快速的写入和从标准输入快速的读入都有可能造成子进程的所，甚至死锁。当Runtime对象调用exec()后，JVM会启动一个子进程，该进程会与JVM进程建立三个管道连接：标准输入，标准输出和标准错误流。假设该程序不断在向标准输出流和标准错误流写数据，而JVM不读取的话，当缓冲区满之后将无法继续写入数据，最终造成阻塞在waitFor()这里。为了避免这种情况的发生，我在执行exe文件的一个进程启动四条线程，分别对标准输入、标准输出、标准错误流进行读写，还有一个线程进行时间的控制。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146 static Process p; /** * 过 Runtime 调用运行 exe 文件 * @param filePath exe 文件绝对路径 * @param inputString 程序读取数据 * @throws InterruptedException * @throws FileNotFoundException */ static public void openApplication(String filePath, final String inputString) throws InterruptedException, FileNotFoundException &#123; File file = new File(filePath); if(!file.exists())&#123; throw new FileNotFoundException(\"找不到exe文件！\"); &#125; try &#123; p = Runtime.getRuntime().exec(filePath); //exe程序数据输出流，相当于进程标准输入流 final BufferedInputStream output = new BufferedInputStream(p.getInputStream()); //exe程序数据输入流 final BufferedOutputStream input = new BufferedOutputStream(p.getOutputStream()); //exe程序错误输出流 final BufferedInputStream errorOutput = new BufferedInputStream(p.getErrorStream()); final StringBuffer outputText = new StringBuffer(\"获得信息是: \\n\"); final StringBuffer errorText = new StringBuffer(\"错误信息是：\\n\"); /** * 向线程进行输入 */ new Thread()&#123; public void run()&#123; try &#123; System.out.println(\"执行输入！\\n\"); //将用户输入数据写入 input.write(inputString.getBytes()); input.flush();//清空存缓 System.out.println(\"----\\n读入完毕\\n---\\n\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(input != null) &#123; try &#123; input.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;.start(); /** * 获得输出的线程 */ new Thread()&#123; public void run()&#123; int ch; try &#123; System.out.println(\"执行输出！\\n\"); //不断获取用户输出 while ((ch = output.read()) != -1) &#123; outputText.append((char) ch); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (output != null)&#123; try &#123; output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;.start(); /** * 获得进程的错误提示 */ new Thread()&#123; public void run()&#123; int ch; try &#123; System.out.println(\"执行错误输出！\\n\"); //不断获取错误输出 while ((ch = errorOutput.read()) != -1) &#123; System.out.println((char) ch); errorText.append((char) ch); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(errorOutput != null)&#123; try &#123; errorOutput.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;.start(); /** * 控制时间的进程 */ Thread timeController = new Thread()&#123; public void run()&#123; try &#123; System.out.println(\"执行时间控制！\\n\"); Thread.sleep(5000); //限制运行时间 //加入错误提示信息 errorText.append(\"\\n运行时间过长！\\n\"); p.destroy(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; if(p != null) &#123; p.destroy(); &#125; &#125; &#125; &#125;; timeController.start(); SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式 //记录执行时间 System.out.println(\"\\n开始执行时间：\"+df.format(new Date()));// new Date()为获取当前系统时间 //一直等待直到“启动成功” int retval = p.waitFor(); //waitfor()结束后，关闭时间控制进程 timeController.stop(); //记录结束时间 System.out.println(\"\\n结束执行时间：\"+df.format(new Date()));// new Date()为获取当前系统时间 System.out.println(outputText); System.out.println(errorText); System.out.println(retval); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(p!=null) &#123; p.destroy(); &#125; &#125; &#125; 参考案例https://github.com/FunriLy/OnlineCompilation","categories":[{"name":"其他奇奇怪怪的","slug":"其他奇奇怪怪的","permalink":"https://zggdczfr.cn/categories/其他奇奇怪怪的/"}],"tags":[{"name":"java","slug":"java","permalink":"https://zggdczfr.cn/tags/java/"}]},{"title":"java调用cmd编译(一)","slug":"java调用cmd编译C文件(一)","date":"2017-02-05T02:21:51.000Z","updated":"2017-02-18T13:14:23.925Z","comments":true,"path":"2017/02/05/java调用cmd编译C文件(一)/","link":"","permalink":"https://zggdczfr.cn/2017/02/05/java调用cmd编译C文件(一)/","excerpt":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。","text":"利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 如何使用Java来编译运行C文件(一)前言码农的小日子过得好好的，指导老师一个兴起要求搞一个自己的在线编译网站，我们这种做小弟的只能老老实实地去搞。还好刚刚结束了考试与比赛，因为各种原因导致原定于寒假开工的项目延迟到下学期了，刚好趁这段空闲的时间来搞一搞。其实，自己感觉搞这个的话也挺好玩的~ 介绍利用java后台来编译运行C源文件，主要是为了开发一个在线编译网站的准备。这里主要介绍如何编译运行C源文件，其实对于其他语言，道理都是一模一样的。 前期技术准备1. 调用cmd编译C文件先说明一下，我的操作系统是Win10，Linux环境下会有所不同；而编译环境是GCC。 打开命令行界面并确认GCC可用123键盘win + r （ 这里的r是run的意思）输入cmd,回车，你就看到了命令行输入gcc -v --如果返回了结果，那么继续，如果不识别，那么请立刻参考“附录” 如： 写好C语言源文件创建test.c文件，输入以下代码：123456#include&lt;stdio.h&gt;int main()&#123; printf(\"hello world\\n\"); getchar(); rerturn 0;&#125; 将.c文件放于E盘中，方便操作。 编译该.c文件12E: cdgcc test.c -o test 这里的cd是change directory的意思 接下来，在E盘中就能找到test.exe文件，双击运行即可。备注：也可通过命令行来运行该文件！ 附录当你输入gcc时，之所以你看到了：1不是内部或外部命令，也不是可运行的程序或批处理文件。 因为你没有在自己的环境变量之中添加gcc.exe的路径。于是系统完全不知道去哪里寻找gcc.exe。关于GCC的安装配置我就不废话了，直接借用CSDN上firefoxbug大神的博文，附上链接Windows下安装配置GCC编译器 2. Java运行命令行java的Runtime.getRuntime().exec(string)可以调用执行cmd指令。123456789cmd /c dir 是执行完dir命令后关闭命令窗口。cmd /k dir 是执行完dir命令后不关闭命令窗口。cmd /c start dir 会打开一个新窗口后执行dir指令，原窗口会关闭。cmd /k start dir 会打开一个新窗口后执行dir指令，原窗口不会关闭。可以用cmd /?查看帮助信息。 附上一个简单的调用demo12345678910111213 public static void main(String[] args) &#123; String string = \"要执行的cmd语句\"; Runtime run = Runtime.getRuntime(); try &#123; Process process = run.exec(\"cmd.exe /k start \" + string); /* 对进程 process 进行操作 */ process.destroy(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 关于多条cmd语句的执行问题在许多情况下，只调用一条cmd语句明显不能满足我们的需求，需要多条cmd语句来共同配合使用。关于网上使用&amp;&amp;来连接多条cmd语句的调用使用，本人亲测不成功，也有可能是我的操作有错(可与网上案例一模一样的代码运行不成功我也没办法啊，也考虑过是Windows操作系统的影响)。最后，我是使用了bat批处理文件来解决这个问题的，具体案例请参考我的开发案例。 常见的CMD命令注意：以下命令均由互联网收集而来！！！1. gpedit.msc—–组策略2. sndrec32——-录音机3. Nslookup——-IP地址侦测器4. explorer——-打开资源管理器5. logoff———注销命令6. tsshutdn——-60秒倒计时关机命令7. lusrmgr.msc—-本机用户和组8. services.msc—本地服务设置9. oobe/msoobe /a—-检查XP是否激活10. notepad——–打开记事本11. cleanmgr——-垃圾整理12. net start messenger—-开始信使服务13. compmgmt.msc—计算机管理14. net stop messenger—–停止信使服务15. conf———–启动netmeeting16. dvdplay——–DVD播放器17. charmap——–启动字符映射表18. diskmgmt.msc—磁盘管理实用程序19. calc———–启动计算器20. dfrg.msc——-磁盘碎片整理程序21. chkdsk.exe—–Chkdsk磁盘检查22. devmgmt.msc— 设备管理器23. regsvr32 /u .dll—-停止dll文件运行24. drwtsn32—— 系统医生25. rononce -p —-15秒关机26. dxdiag———检查DirectX信息27. regedt32——-注册表编辑器28. Msconfig.exe—系统配置实用程序29. rsop.msc——-组策略结果集30. mem.exe——–显示内存使用情况31. regedit.exe—-注册表32. winchat——–XP自带局域网聊天33. progman——–程序管理器34. winmsd———系统信息35. perfmon.msc—-计算机性能监测程序36. winver———检查Windows版本37. sfc /scannow—–扫描错误并复原38. taskmgr—–任务管理器（2000／xp／200339. winver———检查Windows版本40. wmimgmt.msc—-打开windows管理体系结构(WMI)41. wupdmgr——–windows更新程序42. wscript——–windows脚本宿主设置43. write———-写字板44. winmsd———系统信息45. wiaacmgr——-扫描仪和照相机向导46. winchat——–XP自带局域网聊天47. mem.exe——–显示内存使用情况48. Msconfig.exe—系统配置实用程序49. mplayer2——-简易widnows media player50. mspaint——–画图板51. mstsc———-远程桌面连接52. mplayer2——-媒体播放机53. magnify——–放大镜实用程序54. mmc————打开控制台55. mobsync——–同步命令56. dxdiag———检查DirectX信息57. drwtsn32—— 系统医生58. devmgmt.msc— 设备管理器59. dfrg.msc——-磁盘碎片整理程序60. diskmgmt.msc—磁盘管理实用程序61. dcomcnfg——-打开系统组件服务62. ddeshare——-打开DDE共享设置63. dvdplay——–DVD播放器64. net stop messenger—–停止信使服务65. net start messenger—-开始信使服务66. notepad——–打开记事本67. nslookup——-网络管理的工具向导68. ntbackup——-系统备份和还原69. narrator——-屏幕“讲述人”70. ntmsmgr.msc—-移动存储管理器71. ntmsoprq.msc—移动存储管理员操作请求72. netstat -an—-(TC)命令检查接口73. syncapp——–创建一个公文包74. sysedit——–系统配置编辑器75. sigverif——-文件签名验证程序76. sndrec32——-录音机77. shrpubw——–创建共享文件夹78. secpol.msc—–本地安全策略79. syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码80. services.msc—本地服务设置81. Sndvol32——-音量控制程序82. sfc.exe——–系统文件检查器83. sfc /scannow—windows文件保护84. tsshutdn——-60秒倒计时关机命令3. 84. tsshutdn——-60秒倒计时关机命令85. tourstart——xp简介（安装完成后出现的漫游xp程序）86. taskmgr——–任务管理器87. eventvwr——-事件查看器88. eudcedit——-造字程序89. explorer——-打开资源管理器90. packager——-对象包装程序91. perfmon.msc—-计算机性能监测程序92. progman——–程序管理器93. regedit.exe—-注册表94. rsop.msc——-组策略结果集95. regedt32——-注册表编辑器96. rononce -p —-15秒关机97. regsvr32 /u .dll—-停止dll文件运行98. regsvr32 /u zipfldr.dll——取消ZIP支持99. cmd.exe——–CMD命令提示符100. chkdsk.exe—–Chkdsk磁盘检查101. certmgr.msc—-证书管理实用程序102. calc———–启动计算器103. charmap——–启动字符映射表104. cliconfg——-SQL SERVER 客户端网络实用程序105. Clipbrd——–剪贴板查看器106. conf———–启动netmeeting107. compmgmt.msc—计算机管理108. cleanmgr——-垃圾整理109. ciadv.msc——索引服务程序110. osk————打开屏幕键盘111. odbcad32——-ODBC数据源管理器112. oobe/msoobe /a—-检查XP是否激活113. lusrmgr.msc—-本机用户和组114. logoff———注销命令115. iexpress——-木马捆绑工具，系统自带116. Nslookup——-IP地址侦测器117. fsmgmt.msc—–共享文件夹管理器118. utilman——–辅助工具管理器119. gpedit.msc—–组策略120. explorer——-打开资源管理器","categories":[{"name":"其他奇奇怪怪的","slug":"其他奇奇怪怪的","permalink":"https://zggdczfr.cn/categories/其他奇奇怪怪的/"}],"tags":[{"name":"java","slug":"java","permalink":"https://zggdczfr.cn/tags/java/"}]},{"title":"大学有感","slug":"大学有感","date":"2017-02-02T11:35:54.000Z","updated":"2017-02-07T08:49:04.040Z","comments":true,"path":"2017/02/02/大学有感/","link":"","permalink":"https://zggdczfr.cn/2017/02/02/大学有感/","excerpt":"","text":"“天下事有难易乎？为之，则难者亦易矣；不为，则易者亦难矣。”一直以来很喜欢这句话，一直以来无法全心全意投注于自己专注的事情之中，也一直以来朝着话中的信念前进。 在2015年高考惨遭”滑铁卢战役”，可能一直以来我都处于一种”不服”的观念之中。也正是这种”不服”，我总是尽可能地将我的工作做得更好。正如我朋友曾经对我说过，“你总是那么忙，忙于学习、忙于各种任务……”其实，忙一点，还是不错的。在大学一年半的时间内，我完成了3/6自己订下的目标。到今天，我仍然庆幸自己没有堕落，自己能加入一个能”拼命”的团队(QG)中学习如何与他人合作并且不断提高自己，自己仍然能按照自己选择的道路不断挣扎，虽然累可还是在承受范围内。 大学生活以来没有以前想象中那么高端美好，可每个人多多少少还是会有自己的收获。我想，生活本该如此，该玩的时候玩，该静心的时候静心，该学习的时候学习。大学乃至社会之中，各种形形色色、奇奇怪怪的人，自然有他存在的理由，又何必因为他人而轻易影响到自己？与人合作，只要不影响到我的进度，我可以容纳你的各种想法行为，其实是还未能打动我或者说是懒得理你……这就是我今天总结的”生存之道”。 正所谓，人静而后安，安而能后定，定而嫩=能后慧，慧而能后悟，悟而能后得。 ————《大学》","categories":[{"name":"随记感悟","slug":"随记感悟","permalink":"https://zggdczfr.cn/categories/随记感悟/"}],"tags":[]}]}